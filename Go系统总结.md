#### 一、Go基础知识

##### **1、Go的优点**

- 效率高：体现在编译速度比java和c++更快，运行效率媲美C，同时开发效率非常高
- 开发效率高：关键词和语法简单好记，轻松上手易学
- 生态强大：网上的库很丰富，很多功能使用Go开发非常简单(如可以很简单的搭建一个聊天室和一个web服务)
- 高安全性：语法检查严格，错误当场处理，拥有强大的编译检查、严格的代码规范和完整的软件生命周期工具，具有强的稳定性
- 严格的依赖管理：GO1.11版本引入了模块管理机制，通过项目中使用模块，可以实现对依赖包的管理，依赖管理主要体现在以下两方面：
  - 模块管理：每个GO项目位于一个模块中，使用go mod 文件来定义模块的依赖关系并列出所依赖的模块，以及每个模块的版本信息。模块管理可以确保每个项目有自己独立的依赖环境，并且可以精确的控制每个依赖包的版本
  - 版本管理：在GO模块中，依赖包的版本是由模块的发布者通过语义化版本控制来管理的，还支持控制版本的范围
- 跨平台交叉编译：windows就可以编译出mac、linux上可执行的程序，提高了开发效率和代码可移植性
- 异步编程复杂度低，易维护：channnel的设置，异步编程写起来非常自然
- 对并发的友好支持：我们只需简单的通过go关键字就可以开启一个goroutine轻量级线程(又称协程)，创建和调度由go语言直接调度

****

##### **2、GO的基本数据类型**

**计算机数据存储的最小单位为bit(位)，0或者1**

**byte:计算机中数据的基本单元，1字节=8bit，数据在计算机中存储或计算。至少为1个字节**

- **有符号整型**：int(根据操作系统随机分配一般是4~8byte)、int8(1byte)、int32(4byte)、int64(8byte)
- **无符号整型**：uint(根据操作系统随机分配一般是4~8byte)、uint8(1byte)、uint32(4byte)、uint64(8byte)

**Go的传递类型**

> **非引用类型（值类型**）：无法修改原内容数据
>
> 值类型是直接存储在变量中的数据，它们赋值和传递都是按值传递的。当值类型的变量赋值给另一个变量时，会将原始数据复制一份
>
> - 基本数据类型（int、string、float64、byte等）、数组(array)等
> - 结构体(struct)：使用struct关键字定义自定义类型，由多个字段组成
>
> **引用类型**：修改形参，可以修改原内容数据
>
> 引用类型是存储在堆上的数据，变量中存储的是对数据的引用（地址），而不是数据本身。引用类型的复制和传递都是按引用传递的，即传递的是指向底层数据的指针。常见的引用类型包括：
>
> - 切片(slice)：动态数据，使用 []T 表示
> - 映射(map)：键值对集合，使用 map[K]V 表示
> - 通道(channel)：用于goroutine之间传递数据的管道，使用chan T表示
> - 接口(interface)：实际传递接口的值，其中包含了接口底层数据的类型信息和指向底层数据的指针。因此，接口的值传递的是底层数据的一份拷贝，但这份拷贝仍然指向同一个底层数据，所以会修改指向的值
> - 函数(function)：在Go中函数也是一种值，可以像其它类型一样进行传递。当函数当做参数传递给另一个函数时，实际上传递的是函数的引用(地址)。因此，在函数内部可以通过指针修改变量的值，这种修改会影响到原始变量

**go传递方式：**Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝

>- 什么是值传递？
>
>  将实参的值传递给形参，形参是实参的一份拷贝，形参与实参的内存地址不同。函数内对形参内容的修改，取决于参数是否是引用传递
>
>- 什么是引用传递？
>
>  将实参的地址传递给形参，函数内对形参内容的修改，将会影响到实参的值内容，称为引用传递

**总结：值类型传递在复制和传递时会进行复制，而引用类型在复制和传递时将底层数据的指针（地址）传递过去了，可以根据指针获取值，修改会改变变量的值**

##### **3.make和new内置函数区别**

变量初始化，一般包括两个步骤，变量声明+变量内存分配，var关键字就是用来声明变量的，make和new函数主要是用来分配内存的

var声明值类型时，系统**会默认为它分配空间，并赋该类型的零值**(如bool布尔，int整型、string字符串、struct结构体等)

如果是**指针类型或者引用类型的变量，系统不会为它分配内存，默认是nil。此时如果你想直接使用，系统会抛异常**，必须进行内存分配后，才能使用，new和make两个内置函数，主要用来分配内存空间，有了内存空间，变量就能使用了，主要有以下2点区别：

**使用场景区别：**

- make只能用来分配及初始化类型为silice、map、chan的数据
- new可以分配任意类型的数据，并且置零值

**返回值区别：**

- make函数原型如下，返回的是slice、map、chan类型本身

  这三种类型都是引用类型，就没有必要返回他们的指针

  ```
  func make(t Type,size ...IntegerType) Type
  ```

- new函数原型如下，返回一个指向该类型内存地址的指针

  ```
  func new(Type) *Type
  ```

  

##### **4.GMP原理与调度**

什么是调度器？

- 在多进程/多线程的操作系统中，Go调度本质就是把大量的goroutine分配到少量内核态线程去执行，并利用多核并行，实现更强大的并发。

调度器作用？

- 提高CPU的利用率
